{"language":"Solidity","sources":{"PredictionMarketV3UUPS.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IERC20.sol\";\n\ncontract PredictionMarketV3UUPS {\n    bytes32 private constant IMPLEMENTATION_SLOT = bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1);\n    \n    IERC20 public usdc;\n    address public owner;\n    uint8 private _initialized;\n    \n    uint256 public constant PLATFORM_FEE_BPS = 200; // 2% platform fee\n    uint256 public constant BPS_DENOMINATOR = 10000;\n    uint256 public constant CHALLENGE_WINDOW = 24 hours;\n    uint256 public constant MAX_RESOLUTION_TIMEOUT = 7 days;\n    uint256 public constant MIN_PROPOSAL_BOND = 5 * 1e6; // 5 USDC\n    uint256 public constant MIN_CHALLENGE_BOND = 10 * 1e6; // 10 USDC\n    \n    address public constant TREASURY = 0xE9059B5f1C60ecf9C1F07ac2bBa148A75394f56e;\n    \n    enum MarketStatus { OPEN, PENDING_RESOLUTION, RESOLVED, VOIDED }\n    enum Outcome { UNRESOLVED, YES, NO }\n    enum Category { CRYPTO, SPORTS, POLITICS, POP_CULTURE, SCIENCE, OTHER }\n    \n    struct Market {\n        uint256 id;\n        address creator;\n        string question;\n        Category category;\n        uint256 deadline;\n        MarketStatus status;\n        Outcome outcome;\n        uint256 yesPool;\n        uint256 noPool;\n        uint256 totalVolume;\n        // Crypto-specific\n        string targetAsset;\n        uint256 targetPrice;\n        bool priceAbove;\n        // Resolution data\n        uint256 resolvedPrice;\n        uint256 resolvedAt;\n        // Sports-specific (stored in metadata)\n        string metadata; // JSON: {\"teams\": [\"Team A\", \"Team B\"], \"gameId\": \"123\", \"league\": \"NBA\"}\n    }\n    \n    struct Position {\n        uint256 yesShares;\n        uint256 noShares;\n    }\n    \n    struct Proposal {\n        address proposer;\n        Outcome proposedOutcome;\n        uint256 proposedPrice;\n        uint256 proposalTime;\n        uint256 bond;\n        bool challenged;\n        address challenger;\n        uint256 challengeBond;\n        Outcome challengeOutcome;\n        uint256 challengePrice;\n    }\n    \n    uint256 public nextMarketId;\n    mapping(uint256 => Market) public markets;\n    mapping(uint256 => mapping(address => Position)) public positions;\n    mapping(uint256 => Proposal) public proposals;\n    mapping(address => uint256) public userBalances;\n    \n    event MarketCreated(uint256 indexed marketId, address indexed creator, string question, uint256 deadline, string targetAsset, uint256 targetPrice, bool priceAbove);\n    event SharesPurchased(uint256 indexed marketId, address indexed user, bool isYes, uint256 amount, uint256 shares, uint256 price);\n    event OutcomeProposed(uint256 indexed marketId, address indexed proposer, Outcome outcome, uint256 price, uint256 bond);\n    event OutcomeChallenged(uint256 indexed marketId, address indexed challenger, Outcome outcome, uint256 price, uint256 bond);\n    event MarketResolved(uint256 indexed marketId, Outcome outcome, uint256 resolvedPrice, address winner, uint256 reward);\n    event MarketVoided(uint256 indexed marketId);\n    event WinningsClaimed(uint256 indexed marketId, address indexed user, uint256 amount);\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event PlatformFeeCollected(uint256 indexed marketId, uint256 amount);\n    event Upgraded(address indexed implementation);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n    \n    modifier initializer() {\n        require(_initialized == 0, \"Already initialized\");\n        _initialized = 1;\n        _;\n    }\n    \n    constructor() {\n        _initialized = type(uint8).max;\n    }\n    \n    function initialize(address _usdc, address _owner) public initializer {\n        usdc = IERC20(_usdc);\n        owner = _owner;\n        nextMarketId = 1;\n    }\n    \n    function upgradeTo(address newImplementation) external onlyOwner {\n        require(newImplementation != address(0), \"Invalid implementation\");\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            sstore(slot, newImplementation)\n        }\n        emit Upgraded(newImplementation);\n    }\n    \n    function getImplementation() external view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n    \n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid owner\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n    \n    // Sweep any accumulated treasury balance to treasury wallet\n    function sweepTreasuryBalance() external onlyOwner {\n        uint256 balance = userBalances[TREASURY];\n        if (balance > 0) {\n            userBalances[TREASURY] = 0;\n            require(usdc.transfer(TREASURY, balance), \"Transfer failed\");\n        }\n    }\n    \n    // ============ DEPOSIT/WITHDRAW ============\n    \n    function deposit(uint256 amount) external {\n        require(amount > 0, \"Amount must be > 0\");\n        require(usdc.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n        userBalances[msg.sender] += amount;\n        emit Deposited(msg.sender, amount);\n    }\n    \n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"Amount must be > 0\");\n        require(userBalances[msg.sender] >= amount, \"Insufficient balance\");\n        userBalances[msg.sender] -= amount;\n        require(usdc.transfer(msg.sender, amount), \"Transfer failed\");\n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    // ============ MARKET CREATION ============\n    \n    // Create market with full parameters (for all categories)\n    function createMarketFull(\n        string calldata question,\n        Category category,\n        uint256 deadline,\n        string calldata targetAsset,\n        uint256 targetPrice,\n        bool priceAbove,\n        string calldata metadata\n    ) external returns (uint256) {\n        require(deadline > block.timestamp + 1 hours, \"Deadline too soon\");\n        require(bytes(question).length > 0, \"Question required\");\n        \n        // For crypto markets, require target asset and price\n        if (category == Category.CRYPTO) {\n            require(bytes(targetAsset).length > 0, \"Target asset required for crypto\");\n            require(targetPrice > 0, \"Target price required for crypto\");\n        }\n        \n        uint256 marketId = nextMarketId++;\n        \n        markets[marketId] = Market({\n            id: marketId,\n            creator: msg.sender,\n            question: question,\n            category: category,\n            deadline: deadline,\n            status: MarketStatus.OPEN,\n            outcome: Outcome.UNRESOLVED,\n            yesPool: 50 * 1e6,\n            noPool: 50 * 1e6,\n            totalVolume: 0,\n            targetAsset: targetAsset,\n            targetPrice: targetPrice,\n            priceAbove: priceAbove,\n            resolvedPrice: 0,\n            resolvedAt: 0,\n            metadata: metadata\n        });\n        \n        emit MarketCreated(marketId, msg.sender, question, deadline, targetAsset, targetPrice, priceAbove);\n        return marketId;\n    }\n    \n    // Backwards compatible - create crypto market (no metadata)\n    function createMarket(\n        string calldata question,\n        Category category,\n        uint256 deadline,\n        string calldata targetAsset,\n        uint256 targetPrice,\n        bool priceAbove\n    ) external returns (uint256) {\n        require(deadline > block.timestamp + 1 hours, \"Deadline too soon\");\n        require(bytes(question).length > 0, \"Question required\");\n        \n        if (category == Category.CRYPTO) {\n            require(bytes(targetAsset).length > 0, \"Target asset required for crypto\");\n            require(targetPrice > 0, \"Target price required for crypto\");\n        }\n        \n        uint256 marketId = nextMarketId++;\n        \n        markets[marketId] = Market({\n            id: marketId,\n            creator: msg.sender,\n            question: question,\n            category: category,\n            deadline: deadline,\n            status: MarketStatus.OPEN,\n            outcome: Outcome.UNRESOLVED,\n            yesPool: 50 * 1e6,\n            noPool: 50 * 1e6,\n            totalVolume: 0,\n            targetAsset: targetAsset,\n            targetPrice: targetPrice,\n            priceAbove: priceAbove,\n            resolvedPrice: 0,\n            resolvedAt: 0,\n            metadata: \"\"\n        });\n        \n        emit MarketCreated(marketId, msg.sender, question, deadline, targetAsset, targetPrice, priceAbove);\n        return marketId;\n    }\n    \n    // ============ TRADING (AMM) - FIXED CPMM ============\n    \n    function getPrice(uint256 marketId, bool isYes) public view returns (uint256) {\n        Market storage market = markets[marketId];\n        uint256 total = market.yesPool + market.noPool;\n        if (total == 0) return 5000;\n        \n        if (isYes) {\n            return (market.noPool * 10000) / total;\n        } else {\n            return (market.yesPool * 10000) / total;\n        }\n    }\n    \n    function buyShares(uint256 marketId, bool isYes, uint256 amount) external {\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp < market.deadline, \"Market expired\");\n        require(amount > 0, \"Amount must be > 0\");\n        require(userBalances[msg.sender] >= amount, \"Insufficient balance\");\n        \n        // Deduct platform fee first\n        uint256 platformFee = (amount * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        uint256 amountAfterFee = amount - platformFee;\n        \n        uint256 shares;\n        uint256 price = getPrice(marketId, isYes);\n        \n        // FIXED CPMM: k = yesPool * noPool (constant product)\n        // When buying YES: Add to noPool (payment), calculate shares from yesPool decrease\n        // When buying NO: Add to yesPool (payment), calculate shares from noPool decrease\n        uint256 k = market.yesPool * market.noPool;\n        \n        if (isYes) {\n            // User pays into noPool, receives yesShares\n            uint256 newNoPool = market.noPool + amountAfterFee;\n            uint256 newYesPool = k / newNoPool;\n            shares = market.yesPool - newYesPool;\n            market.yesPool = newYesPool;\n            market.noPool = newNoPool;\n        } else {\n            // User pays into yesPool, receives noShares\n            uint256 newYesPool = market.yesPool + amountAfterFee;\n            uint256 newNoPool = k / newYesPool;\n            shares = market.noPool - newNoPool;\n            market.noPool = newNoPool;\n            market.yesPool = newYesPool;\n        }\n        \n        require(shares > 0, \"No shares to buy\");\n        \n        userBalances[msg.sender] -= amount;\n        \n        // Auto-forward fee directly to treasury wallet\n        require(usdc.transfer(TREASURY, platformFee), \"Fee transfer failed\");\n        \n        Position storage pos = positions[marketId][msg.sender];\n        if (isYes) {\n            pos.yesShares += shares;\n        } else {\n            pos.noShares += shares;\n        }\n        \n        market.totalVolume += amount;\n        \n        emit PlatformFeeCollected(marketId, platformFee);\n        emit SharesPurchased(marketId, msg.sender, isYes, amount, shares, price);\n    }\n    \n    event SharesSold(uint256 indexed marketId, address indexed user, bool isYes, uint256 shares, uint256 amount, uint256 price);\n    \n    function sellShares(uint256 marketId, bool isYes, uint256 sharesToSell) external {\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp < market.deadline, \"Market expired\");\n        require(sharesToSell > 0, \"Shares must be > 0\");\n        \n        Position storage pos = positions[marketId][msg.sender];\n        if (isYes) {\n            require(pos.yesShares >= sharesToSell, \"Insufficient YES shares\");\n        } else {\n            require(pos.noShares >= sharesToSell, \"Insufficient NO shares\");\n        }\n        \n        uint256 payout;\n        uint256 price = getPrice(marketId, isYes);\n        \n        // CPMM sell: reverse of buy\n        // When selling YES: Add shares back to yesPool, remove from noPool\n        // When selling NO: Add shares back to noPool, remove from yesPool\n        uint256 k = market.yesPool * market.noPool;\n        \n        if (isYes) {\n            // User sells yesShares, receives from noPool\n            uint256 newYesPool = market.yesPool + sharesToSell;\n            uint256 newNoPool = k / newYesPool;\n            payout = market.noPool - newNoPool;\n            market.yesPool = newYesPool;\n            market.noPool = newNoPool;\n            pos.yesShares -= sharesToSell;\n        } else {\n            // User sells noShares, receives from yesPool\n            uint256 newNoPool = market.noPool + sharesToSell;\n            uint256 newYesPool = k / newNoPool;\n            payout = market.yesPool - newYesPool;\n            market.noPool = newNoPool;\n            market.yesPool = newYesPool;\n            pos.noShares -= sharesToSell;\n        }\n        \n        require(payout > 0, \"No payout\");\n        \n        // Deduct platform fee from payout\n        uint256 platformFee = (payout * PLATFORM_FEE_BPS) / BPS_DENOMINATOR;\n        uint256 payoutAfterFee = payout - platformFee;\n        \n        userBalances[msg.sender] += payoutAfterFee;\n        \n        // Auto-forward fee directly to treasury wallet\n        require(usdc.transfer(TREASURY, platformFee), \"Fee transfer failed\");\n        \n        market.totalVolume += payout;\n        \n        emit PlatformFeeCollected(marketId, platformFee);\n        emit SharesSold(marketId, msg.sender, isYes, sharesToSell, payoutAfterFee, price);\n    }\n    \n    // ============ PERMISSIONLESS RESOLUTION ============\n    \n    // For CRYPTO markets - uses price to determine outcome\n    function proposeOutcomeWithPrice(uint256 marketId, uint256 currentPrice) external {\n        Market storage market = markets[marketId];\n        require(market.category == Category.CRYPTO, \"Use proposeOutcome for non-crypto\");\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp >= market.deadline, \"Market not expired\");\n        require(userBalances[msg.sender] >= MIN_PROPOSAL_BOND, \"Insufficient bond\");\n        \n        Proposal storage existing = proposals[marketId];\n        require(existing.proposer == address(0), \"Already proposed\");\n        \n        userBalances[msg.sender] -= MIN_PROPOSAL_BOND;\n        \n        Outcome outcome;\n        if (market.priceAbove) {\n            outcome = currentPrice >= market.targetPrice ? Outcome.YES : Outcome.NO;\n        } else {\n            outcome = currentPrice < market.targetPrice ? Outcome.YES : Outcome.NO;\n        }\n        \n        proposals[marketId] = Proposal({\n            proposer: msg.sender,\n            proposedOutcome: outcome,\n            proposedPrice: currentPrice,\n            proposalTime: block.timestamp,\n            bond: MIN_PROPOSAL_BOND,\n            challenged: false,\n            challenger: address(0),\n            challengeBond: 0,\n            challengeOutcome: Outcome.UNRESOLVED,\n            challengePrice: 0\n        });\n        \n        market.status = MarketStatus.PENDING_RESOLUTION;\n        \n        emit OutcomeProposed(marketId, msg.sender, outcome, currentPrice, MIN_PROPOSAL_BOND);\n    }\n    \n    // For NON-CRYPTO markets - direct YES/NO proposal\n    function proposeOutcome(uint256 marketId, bool isYes) external {\n        Market storage market = markets[marketId];\n        require(market.status == MarketStatus.OPEN, \"Market not open\");\n        require(block.timestamp >= market.deadline, \"Market not expired\");\n        require(userBalances[msg.sender] >= MIN_PROPOSAL_BOND, \"Insufficient bond\");\n        \n        Proposal storage existing = proposals[marketId];\n        require(existing.proposer == address(0), \"Already proposed\");\n        \n        userBalances[msg.sender] -= MIN_PROPOSAL_BOND;\n        \n        Outcome outcome = isYes ? Outcome.YES : Outcome.NO;\n        \n        proposals[marketId] = Proposal({\n            proposer: msg.sender,\n            proposedOutcome: outcome,\n            proposedPrice: 0,\n            proposalTime: block.timestamp,\n            bond: MIN_PROPOSAL_BOND,\n            challenged: false,\n            challenger: address(0),\n            challengeBond: 0,\n            challengeOutcome: Outcome.UNRESOLVED,\n            challengePrice: 0\n        });\n        \n        market.status = MarketStatus.PENDING_RESOLUTION;\n        \n        emit OutcomeProposed(marketId, msg.sender, outcome, 0, MIN_PROPOSAL_BOND);\n    }\n    \n    // Challenge with price (for CRYPTO)\n    function challengeOutcomeWithPrice(uint256 marketId, uint256 correctPrice) external {\n        Market storage market = markets[marketId];\n        Proposal storage proposal = proposals[marketId];\n        \n        require(market.category == Category.CRYPTO, \"Use challengeOutcome for non-crypto\");\n        require(market.status == MarketStatus.PENDING_RESOLUTION, \"Not pending\");\n        require(block.timestamp < proposal.proposalTime + CHALLENGE_WINDOW, \"Challenge window closed\");\n        require(!proposal.challenged, \"Already challenged\");\n        require(userBalances[msg.sender] >= MIN_CHALLENGE_BOND, \"Insufficient bond\");\n        \n        Outcome newOutcome;\n        if (market.priceAbove) {\n            newOutcome = correctPrice >= market.targetPrice ? Outcome.YES : Outcome.NO;\n        } else {\n            newOutcome = correctPrice < market.targetPrice ? Outcome.YES : Outcome.NO;\n        }\n        \n        require(newOutcome != proposal.proposedOutcome, \"Same outcome\");\n        \n        userBalances[msg.sender] -= MIN_CHALLENGE_BOND;\n        \n        proposal.challenged = true;\n        proposal.challenger = msg.sender;\n        proposal.challengeBond = MIN_CHALLENGE_BOND;\n        proposal.challengeOutcome = newOutcome;\n        proposal.challengePrice = correctPrice;\n        \n        emit OutcomeChallenged(marketId, msg.sender, newOutcome, correctPrice, MIN_CHALLENGE_BOND);\n    }\n    \n    // Challenge with direct outcome (for NON-CRYPTO)\n    function challengeOutcome(uint256 marketId) external {\n        Market storage market = markets[marketId];\n        Proposal storage proposal = proposals[marketId];\n        \n        require(market.status == MarketStatus.PENDING_RESOLUTION, \"Not pending\");\n        require(block.timestamp < proposal.proposalTime + CHALLENGE_WINDOW, \"Challenge window closed\");\n        require(!proposal.challenged, \"Already challenged\");\n        require(userBalances[msg.sender] >= MIN_CHALLENGE_BOND, \"Insufficient bond\");\n        \n        // Challenger proposes the opposite outcome\n        Outcome newOutcome = proposal.proposedOutcome == Outcome.YES ? Outcome.NO : Outcome.YES;\n        \n        userBalances[msg.sender] -= MIN_CHALLENGE_BOND;\n        \n        proposal.challenged = true;\n        proposal.challenger = msg.sender;\n        proposal.challengeBond = MIN_CHALLENGE_BOND;\n        proposal.challengeOutcome = newOutcome;\n        proposal.challengePrice = 0;\n        \n        emit OutcomeChallenged(marketId, msg.sender, newOutcome, 0, MIN_CHALLENGE_BOND);\n    }\n    \n    function finalizeResolution(uint256 marketId) external {\n        Market storage market = markets[marketId];\n        Proposal storage proposal = proposals[marketId];\n        \n        require(market.status == MarketStatus.PENDING_RESOLUTION, \"Not pending\");\n        require(block.timestamp >= proposal.proposalTime + CHALLENGE_WINDOW, \"Challenge window open\");\n        \n        if (proposal.challenged) {\n            uint256 totalBonds = proposal.bond + proposal.challengeBond;\n            \n            if (proposal.challengeBond > proposal.bond) {\n                market.status = MarketStatus.RESOLVED;\n                market.outcome = proposal.challengeOutcome;\n                market.resolvedPrice = proposal.challengePrice;\n                market.resolvedAt = block.timestamp;\n                userBalances[proposal.challenger] += totalBonds;\n                emit MarketResolved(marketId, proposal.challengeOutcome, proposal.challengePrice, proposal.challenger, totalBonds);\n            } else {\n                market.status = MarketStatus.RESOLVED;\n                market.outcome = proposal.proposedOutcome;\n                market.resolvedPrice = proposal.proposedPrice;\n                market.resolvedAt = block.timestamp;\n                userBalances[proposal.proposer] += totalBonds;\n                emit MarketResolved(marketId, proposal.proposedOutcome, proposal.proposedPrice, proposal.proposer, totalBonds);\n            }\n        } else {\n            market.status = MarketStatus.RESOLVED;\n            market.outcome = proposal.proposedOutcome;\n            market.resolvedPrice = proposal.proposedPrice;\n            market.resolvedAt = block.timestamp;\n            userBalances[proposal.proposer] += proposal.bond;\n            emit MarketResolved(marketId, proposal.proposedOutcome, proposal.proposedPrice, proposal.proposer, proposal.bond);\n        }\n    }\n    \n    function voidMarket(uint256 marketId) external {\n        Market storage market = markets[marketId];\n        Proposal storage proposal = proposals[marketId];\n        \n        require(market.status == MarketStatus.OPEN || market.status == MarketStatus.PENDING_RESOLUTION, \"Cannot void\");\n        require(block.timestamp > market.deadline + MAX_RESOLUTION_TIMEOUT, \"Timeout not reached\");\n        \n        if (proposal.proposer != address(0)) {\n            userBalances[proposal.proposer] += proposal.bond;\n            if (proposal.challenged) {\n                userBalances[proposal.challenger] += proposal.challengeBond;\n            }\n        }\n        \n        market.status = MarketStatus.VOIDED;\n        emit MarketVoided(marketId);\n    }\n    \n    // ============ CLAIM WINNINGS ============\n    \n    function claimWinnings(uint256 marketId) external {\n        Market storage market = markets[marketId];\n        Position storage pos = positions[marketId][msg.sender];\n        \n        require(market.status == MarketStatus.RESOLVED || market.status == MarketStatus.VOIDED, \"Market not resolved\");\n        require(pos.yesShares > 0 || pos.noShares > 0, \"No position\");\n        \n        uint256 payout = 0;\n        \n        if (market.status == MarketStatus.VOIDED) {\n            uint256 totalShares = pos.yesShares + pos.noShares;\n            payout = totalShares;\n        } else if (market.outcome == Outcome.YES) {\n            payout = pos.yesShares;\n        } else if (market.outcome == Outcome.NO) {\n            payout = pos.noShares;\n        }\n        \n        pos.yesShares = 0;\n        pos.noShares = 0;\n        \n        if (payout > 0) {\n            userBalances[msg.sender] += payout;\n            emit WinningsClaimed(marketId, msg.sender, payout);\n        }\n    }\n    \n    // ============ VIEW FUNCTIONS ============\n    \n    function getMarket(uint256 marketId) external view returns (Market memory) {\n        return markets[marketId];\n    }\n    \n    function getPosition(uint256 marketId, address user) external view returns (Position memory) {\n        return positions[marketId][user];\n    }\n    \n    function getProposal(uint256 marketId) external view returns (Proposal memory) {\n        return proposals[marketId];\n    }\n    \n    function getUserBalance(address user) external view returns (uint256) {\n        return userBalances[user];\n    }\n    \n    function getTreasury() external pure returns (address) {\n        return TREASURY;\n    }\n    \n    function getVersion() external pure returns (string memory) {\n        return \"3.0.0-UUPS\";\n    }\n}\n"},"interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function decimals() external view returns (uint8);\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"viaIR":true,"outputSelection":{"*":{"*":["abi","evm.bytecode.object"]}}}}